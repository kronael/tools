#!/bin/bash

# rig - ripgit: git tools
# Busybox-style: symlinks (rio, rip, rir, rim) detect
# invocation name and dispatch to subcommands.
# All commands fetch by default. -z/--offline suppresses.

# ── Shared helpers ──────────────────────────────────────────────────

dedupe(){ awk '!seen[$0]++'; }
strip_origin(){ sed 's|^origin/||'; }

recent(){
    git reflog --format='%gs' --all \
        | grep -oP 'checkout: moving from .* to \K.*' \
        | dedupe \
        | head -50
}

all(){
    git for-each-ref --sort=-committerdate \
        --format='%(refname:short)' refs/heads refs/remotes
}

branches(){ { recent; all; } | strip_origin | dedupe; }

clean_branch(){
    local b=$1
    while [[ "$b" =~ ^(origin/|refs/|heads/|remotes/) ]]; do
        b=${b#origin/}; b=${b#refs/}
        b=${b#heads/}; b=${b#remotes/}
    done
    echo "$b"
}

get_current_branch(){
    local head=HEAD
    while :; do
        local this=$(git name-rev --name-only $head 2>/dev/null)
        [[ "$this" != "undefined" && -n "$this" ]] && break
        head+=^
    done
    clean_branch "$this"
}

# true if arg resolves to a commit but isn't a known branch
is_commit_not_branch(){
    git rev-parse --verify "$1^{commit}" &>/dev/null \
        && ! git show-ref --verify --quiet "refs/heads/$1" \
        && ! git show-ref --verify --quiet "refs/remotes/origin/$1"
}

# fzf with auto-select unless ? is passed
pick_branch(){
    if [[ "$1" == "?" ]]; then
        branches | fzf --height=40%
    else
        branches | fzf --height=40% --select-1 --exit-0 \
            --query="$1"
    fi
}

# ── Subcommands ─────────────────────────────────────────────────────

cmd_checkout(){
    # Parse flags
    local fetch=1
    while [[ "${1:-}" =~ ^- ]]; do
        case "$1" in
            -z|--offline) fetch=; shift ;;
            -n) local dryrun=1; shift ;;
            -h|--help)
                cat <<EOF
rig checkout - Smart branch checkout with fzf

Usage: rig checkout [-z] [-n] [pattern]
Flags: -z offline (no fetch), -n dry-run, ? force fzf
Examples: rio apm, rio -z apm, rio -n apm, rio ?
EOF
                exit 0 ;;
            *) echo "error: unknown flag: $1"; exit 1 ;;
        esac
    done

    # Select branch
    local branch=$(pick_branch "$1")
    [[ -z "$branch" ]] && {
        echo "error: no branch selected"; exit 1
    }

    # Execute
    if [[ ${dryrun:-} ]]; then
        echo "origin/$branch"
    else
        [[ $fetch ]] && git fetch
        git checkout "origin/$branch"
    fi
}

cmd_push(){
    # Parse flags
    while [[ "${1:-}" =~ ^- ]]; do
        case "$1" in
            -n) local dryrun=1; shift ;;
            -h|--help)
                cat <<EOF
rig push - Smart push to origin

Usage: rig push [-n] [branch[:commit]] [git-push-flags]
Flags: -n dry-run, ? interactive selection
Examples: rip, rip -n, rig p my-branch -f,
          rig p my-branch:abc123
EOF
                exit 0 ;;
            *) break ;;
        esac
    done

    # Select branch and commit
    local branch commit="HEAD"
    case "${1:-}" in
        "")  branch=$(get_current_branch) ;;
        "?") branch=$(pick_branch "?")
             [[ -z "$branch" ]] && exit 1; shift ;;
        *:*) branch=$(clean_branch "${1%:*}")
             commit=${1#*:}; shift ;;
        *)   if is_commit_not_branch "$1"; then
                 echo "warn: '$1' looks like a commit, not a branch"
                 echo "      use branch:commit syntax to push a specific commit"
                 branch=$(get_current_branch)
             else
                 branch=$(clean_branch "$1")
             fi; shift ;;
    esac

    # Validate
    [[ -z "$branch" || "$branch" == "undefined" ]] && {
        echo "error: could not determine branch"
        echo "usage: rig push [branch] or rig push ?"
        exit 1
    }

    # Execute
    if [[ ${dryrun:-} ]]; then
        echo "git push origin $@ $commit:refs/heads/$branch"
    else
        git push origin "$@" "$commit:refs/heads/$branch"
    fi
}

cmd_rebase(){
    # Parse flags
    local fetch=1
    while [[ "${1:-}" =~ ^- ]]; do
        case "$1" in
            -z|--offline) fetch=; shift ;;
            -n) local dryrun=1; shift ;;
            -h|--help)
                cat <<EOF
rig rebase - Smart interactive rebase on origin branch

Usage: rig rebase [-z] [-n] [pattern]
Flags: -z offline (no fetch), -n dry-run, ? force fzf
Examples: rir main, rig r main, rir -z main, rir ?
EOF
                exit 0 ;;
            *) echo "error: unknown flag: $1"; exit 1 ;;
        esac
    done

    # Select branch
    local branch=$(pick_branch "$1")
    [[ -z "$branch" ]] && {
        echo "error: no branch selected"; exit 1
    }

    # Execute
    if [[ ${dryrun:-} ]]; then
        echo "origin/$branch"
    else
        [[ $fetch ]] && git fetch
        git rebase -i "origin/$branch"
    fi
}

cmd_merge(){
    # Parse flags
    local fetch=1
    while [[ "${1:-}" =~ ^- ]]; do
        case "$1" in
            -z|--offline) fetch=; shift ;;
            -n) local dryrun=1; shift ;;
            -h|--help)
                cat <<EOF
rig merge - Smart merge from origin branch

Usage: rig merge [-z] [-n] [pattern]
Flags: -z offline (no fetch), -n dry-run, ? force fzf
Examples: rim main, rig m main, rim -z main, rim ?
EOF
                exit 0 ;;
            *) echo "error: unknown flag: $1"; exit 1 ;;
        esac
    done

    # Select branch
    local branch=$(pick_branch "$1")
    [[ -z "$branch" ]] && {
        echo "error: no branch selected"; exit 1
    }

    # Execute
    if [[ ${dryrun:-} ]]; then
        echo "origin/$branch"
    else
        [[ $fetch ]] && git fetch
        git merge "origin/$branch"
    fi
}

# ── Install ──────────────────────────────────────────────────────────

cmd_install(){
    local dir=$(dirname "$(readlink -f "$0")")
    local symlinks=(rio rip rir rim)
    for s in "${symlinks[@]}"; do
        ln -sf rig "$dir/$s"
        echo "  $dir/$s -> rig"
    done
    echo "installed ${#symlinks[@]} symlinks"
}

# ── Dispatch ────────────────────────────────────────────────────────

usage(){
    cat <<EOF
rig - ripgit: git tools

Usage:
  rig checkout [pattern]  Fetch + checkout origin (rio)
  rig push [branch]       Push HEAD to origin (rip)
  rig rebase [pattern]    Fetch + rebase -i origin (rir)
  rig merge [pattern]     Fetch + merge origin (rim)
  rig install             Create symlinks (rio, rip, rir, rim)

Flags: -z offline (no fetch), -n dry-run, ? force fzf

Symlinks:
  rio apm     fetch + checkout    rip branch   push
  rir main    fetch + rebase -i   rim main     fetch + merge
EOF
    exit 1
}

# Busybox-style: detect how we were called
case "$(basename "$0")" in
    rio) cmd_checkout "$@"; exit ;;
    rip) cmd_push "$@"; exit ;;
    rir) cmd_rebase "$@"; exit ;;
    rim) cmd_merge "$@"; exit ;;
esac

# Normal invocation: rig <cmd> [args]
cmd=${1:-}
shift 2>/dev/null

case "$cmd" in
    co|checkout) cmd_checkout "$@" ;;
    p|push)      cmd_push "$@" ;;
    r|rebase)    cmd_rebase "$@" ;;
    m|merge)     cmd_merge "$@" ;;
    install)     cmd_install ;;
    -h|--help|help|"") usage ;;
    *) echo "error: unknown command: $cmd"; usage ;;
esac
